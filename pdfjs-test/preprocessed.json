[{"title":"Abstract","text":"Dynamic languages such as JavaScript are more difficult to com-pile than statically typed ones. Since no concrete type informationis available, traditional compilers need to emit generic code that canhandle all possible type combinations at runtime. We present an al-ternative compilation technique for dynamically-typed languagesthat identifies frequently executed loop traces at run-time and thengenerates machine code on the fly that is specialized for the ac-tual dynamic types occurring on each path through the loop. Ourmethod provides cheap inter-procedural type specialization, and anelegant and efficient way of incrementally compiling lazily discov-ered alternative paths through nested loops. We have implementeda dynamic compiler for JavaScript based on our technique and wehave measured speedups of 10x and more for certain benchmarkprograms.Categories and Subject DescriptorsD.3.4 [Programming Lan-guages]: Processors —Incremental compilers, code generation.General TermsDesign, Experimentation, Measurement, Perfor-mance.KeywordsJavaScript, just-in-time compilation, trace trees."},{"title":"Introduction","text":"Dynamic languagessuch as JavaScript, Python, and Ruby, are pop-ular since they are expressive, accessible to non-experts, and makedeployment as easy as distributing a source file. They are used forsmall scripts as well as for complex applications. JavaScript, forexample, is the de facto standard for client-side web programmingand is used for the application logic of browser-based productivityapplications such as Google Mail, Google Docs and Zimbra Col-laboration Suite. In this domain, in order to provide a fluid userexperience and enable a new generation of applications, virtual ma-chines must provide a low startup time and high performance.Compilers for statically typed languages rely on type informa-tion to generate efficient machine code. In a dynamically typed pro-gramming language such as JavaScript, the types of expressionsmay vary at runtime. This means that the compiler can no longereasily transform operations into machine instructions that operateon one specific type. Without exact type information, the compilermust emit slower generalized machine code that can deal with allpotential type combinations. While compile-time static type infer-ence might be able to gather type information to generate opti-mized machine code, traditional static analysis is very expensiveand hence not well suited for the highly interactive environment ofa web browser.We present a trace-based compilation technique for dynamiclanguages that reconciles speed of compilation with excellent per-formance of the generated machine code. Our system uses a mixed-mode execution approach: the system starts running JavaScript in afast-starting bytecode interpreter. As the program runs, the systemidentifieshot(frequently executed) bytecode sequences, recordsthem, and compiles them to fast native code. We call such a se-quence of instructions atrace.Unlike method-based dynamic compilers, our dynamic com-piler operates at the granularity of individual loops. This designchoice is based on the expectation that programs spend most oftheir time in hot loops. Even in dynamically typed languages, weexpect hot loops to be mostlytype-stable, meaning that the types ofvalues are invariant. (12) For example, we would expect loop coun-ters that start as integers to remain integers for all iterations. Whenboth of these expectations hold, a trace-based compiler can coverthe program execution with a small number of type-specialized, ef-ficiently compiled traces.Each compiled trace covers one path through the program withone mapping of values to types. When the VM executes a compiledtrace, it cannot guarantee that the same path will be followedor that the same types will occur in subsequent loop iterations.Hence, recording and compiling a tracespeculatesthat the path andtyping will be exactly as they were during recording for subsequentiterations of the loop.Every compiled trace contains all theguards(checks) requiredto validate the speculation. If one of the guards fails (if controlflow is different, or a value of a different type is generated), thetrace exits. If an exit becomes hot, the VM can record abranchtracestarting at the exit to cover the new path. In this way, the VMrecords atrace treecovering all the hot paths through the loop.Nested loops can be difficult to optimize for tracing VMs. Ina na ̈ıve implementation, inner loops would become hot first, andthe VM would start tracing there. When the inner loop exits, theVM would detect that a different branch was taken. The VM wouldtry to record a branch trace, and find that the trace reaches not theinner loop header, but the outer loop header. At this point, the VMcould continue tracing until it reaches the inner loop header again,thus tracing the outer loop inside a trace tree for the inner loop.But this requires tracing a copy of the outer loop for every side exitand type combination in the inner loop. In essence, this is a formof unintended tail duplication, which can easily overflow the codecache. Alternatively, the VM could simply stop tracing, and give upon ever tracing outer loops.We solve the nested loop problem by recordingnested tracetrees. Our system traces the inner loop exactly as the na ̈ıve version.The system stops extending the inner tree when it reaches an outerloop, but then it starts a new trace at the outer loop header. Whenthe outer loop reaches the inner loop header, the system tries to callthe trace tree for the inner loop. If the call succeeds, the VM recordsthe call to the inner tree as part of the outer trace and finishesthe outer trace as normal. In this way, our system can trace anynumber of loops nested to any depth without causing excessive tailduplication.These techniques allow a VM to dynamically translate a pro-gram to nested, type-specialized trace trees. Because traces cancross function call boundaries, our techniques also achieve the ef-fects of inlining. Because traces have no internal control-flow joins,they can be optimized in linear time by a simple compiler (10).Thus, our tracing VM efficiently performs the same kind of op-timizations that would require interprocedural analysis in a staticoptimization setting. This makes tracing an attractive and effectivetool to type specialize even complex function call-rich code.We implemented these techniques for an existing JavaScript in-terpreter, SpiderMonkey. We call the resulting tracing VMTrace-Monkey. TraceMonkey supports all the JavaScript features of Spi-derMonkey, with a 2x-20x speedup for traceable programs.This paper makes the following contributions:We explain an algorithm for dynamically forming trace trees tocover a program, representing nested loops as nested trace trees.We explain how to speculatively generate efficient type-specializedcode for traces from dynamic language programs.We validate our tracing techniques in an implementation basedon the SpiderMonkey JavaScript interpreter, achieving 2x-20xspeedups on many programs.The remainder of this paper is organized as follows. Section 3 isa general overview of trace tree based compilation we use to cap-ture and compile frequently executed code regions. In Section 4we describe our approach of covering nested loops using a num-ber of individual trace trees. In Section 5 we describe our trace-compilation based speculative type specialization approach we useto generate efficient machine code from recorded bytecode traces.Our implementation of a dynamic type-specializing compiler forJavaScript is described in Section 6. Related work is discussed inSection 8. In Section 7 we evaluate our dynamic compiler based on1 for (var i = 2; i < 100; ++i) {2if (!primes[i])3continue;4for (var k = i + i; i < 100; k += i)5primes[k] = false;6 }Figure 1. Sample program: sieve of Eratosthenes.primesisinitialized to an array of 100falsevalues on entry to this codesnippet.Figure 2.State machine describing the major activities of Trace-Monkey and the conditions that cause transitions to a new activ-ity. In the dark box, TM executes JS as compiled traces. In thelight gray boxes, TM executes JS in the standard interpreter. Whiteboxes are overhead. Thus, to maximize performance, we need tomaximize time spent in the darkest box and minimize time spent inthe white boxes. The best case is a loop where the types at the loopedge are the same as the types on entry–then TM can stay in nativecode until the loop is done.a set of industry benchmarks. The paper ends with conclusions inSection 9 and an outlook on future work is presented in Section 10."},{"title":"Overview: Example Tracing Run","text":"This section provides an overview of our system by describinghow TraceMonkey executes an example program. The exampleprogram, shown in Figure 1, computes the first 100 prime numberswith nested loops. The narrative should be read along with Figure 2,which describes the activities TraceMonkey performs and when ittransitions between the loops.TraceMonkey always begins executing a program in the byte-code interpreter. Every loop back edge is a potential trace point.When the interpreter crosses a loop edge, TraceMonkey invokesthetrace monitor, which may decide to record or execute a nativetrace. At the start of execution, there are no compiled traces yet, sothe trace monitor counts the number of times each loop back edge isexecuted until a loop becomeshot, currently after 2 crossings. Notethat the way our loops are compiled, the loop edge is crossed beforeentering the loop, so the second crossing occurs immediately afterthe first iteration.Here is the sequence of events broken down by outer loopiteration:v0 := ld state[748]// load primes from the trace activation recordst sp[0], v0// store primes to interpreter stackv1 := ld state[764]// load k from the trace activation recordv2 := i2f(v1)// convert k from int to doublest sp[8], v1// store k to interpreter stackst sp[16], 0// store false to interpreter stackv3 := ld v0[4]// load class word for primesv4 := and v3, -4// mask out object class tag for primesv5 := eq v4, Array// test whether primes is an arrayxf v5// side exit if v5 is falsev6 := js_Array_set(v0, v2, false)// call function to set array elementv7 := eq v6, 0// test return value from callxt v7// side exit if js_Array_set returns false.Figure 3. LIR snippet for sample program.This is the LIR recorded for line 5 of the sample program in Figure 1. The LIR encodesthe semantics in SSA form using temporary variables. The LIR also encodes all the stores that the interpreter would do to its data stack.Sometimes these stores can be optimized away as the stack locations are live only on exits to the interpreter. Finally, the LIR records guardsand side exits to verify the assumptions made in this recording: thatprimesis an array and that the call to set its element succeeds.mov edx, ebx(748)// load primes from the trace activation recordmov edi(0), edx// (*) store primes to interpreter stackmov esi, ebx(764)// load k from the trace activation recordmov edi(8), esi// (*) store k to interpreter stackmov edi(16), 0// (*) store false to interpreter stackmov eax, edx(4)// (*) load object class word for primesand eax, -4// (*) mask out object class tag for primescmp eax, Array// (*) test whether primes is an arrayjne side_exit_1// (*) side exit if primes is not an arraysub esp, 8// bump stack for call alignment conventionpush false// push last argument for callpush esi// push first argument for callcall js_Array_set// call function to set array elementadd esp, 8// clean up extra stack spacemov ecx, ebx// (*) created by register allocatortest eax, eax// (*) test return value of js_Array_setje side_exit_2// (*) side exit if call failed...side_exit_1:mov ecx, ebp(-4)// restore ecxmov esp, ebp// restore espjmp epilog// jump to ret statementFigure 4. x86 snippet for sample program.This is the x86 code compiled from the LIR snippet in Figure 3. Most LIR instructions compileto a single x86 instruction. Instructions marked with(*)would be omitted by an idealized compiler that knew that none of the side exitswould ever be taken. The 17 instructions generated by the compiler compare favorably with the 100+ instructions that the interpreter wouldexecute for the same code snippet, including 4 indirect jumps.i=2.This is the first iteration of the outer loop. The loop onlines 4-5 becomes hot on its second iteration, so TraceMonkey en-ters recording mode on line 4. In recording mode, TraceMonkeyrecords the code along the trace in a low-level compiler intermedi-ate representation we callLIR. The LIR trace encodes all the oper-ations performed and the types of all operands. The LIR trace alsoencodesguards, which are checks that verify that the control flowand types are identical to those observed during trace recording.Thus, on later executions, if and only if all guards are passed, thetrace has the required program semantics.TraceMonkey stops recording when execution returns to theloop header or exits the loop. In this case, execution returns to theloop header on line 4.After recording is finished, TraceMonkey compiles the trace tonative code using the recorded type information for optimization.The result is a native code fragment that can be entered if theinterpreter PC and the types of values match those observed whentrace recording was started. The first trace in our example,T,covers lines 4 and 5. This trace can be entered if the PC is at line 4,iandkare integers, andprimesis an object. After compilingT,TraceMonkey returns to the interpreter and loops back to line 1.i=3.Now the loop header at line 1 has become hot, so Trace-Monkey starts recording. When recording reaches line 4, Trace-Monkey observes that it has reached an inner loop header that al-ready has a compiled trace, so TraceMonkey attempts to nest theinner loop inside the current trace. The first step is to call the innertrace as a subroutine. This executes the loop on line 4 to completionand then returns to the recorder. TraceMonkey verifies that the callwas successful and then records the call to the inner trace as part ofthe current trace. Recording continues until execution reaches line1, and at which point TraceMonkey finishes and compiles a tracefor the outer loop,T.i=4.On this iteration, TraceMonkey callsT. Becausei=4, theifstatement on line 2 is taken. This branch was not taken in theoriginal trace, so this causesTto fail a guard and take a side exit.The exit is not yet hot, so TraceMonkey returns to the interpreter,which executes the continue statement.i=5.TraceMonkey callsT, which in turn calls the nested traceT.Tloops back to its own header, starting the next iterationwithout ever returning to the monitor.i=6.On this iteration, the side exit on line 2 is taken again. Thistime, the side exit becomes hot, so a traceTis recorded thatcovers line 3 and returns to the loop header. Thus, the end ofTjumps directly to the start ofT. The side exit is patched so thaton future iterations, it jumps directly toT.At this point, TraceMonkey has compiled enough traces to coverthe entire nested loop structure, so the rest of the program runsentirely as native code."},{"title":"Trace Trees","text":"In this section, we describe traces, trace trees, and how they areformed at run time. Although our techniques apply to any dynamiclanguage interpreter, we will describe them assuming a bytecodeinterpreter to keep the exposition simple.3.1TracesAtraceis simply a program path, which may cross function callboundaries. TraceMonkey focuses onloop traces, that originate ata loop edge and represent a single iteration through the associatedloop.Similar to an extended basic block, a trace is only entered atthe top, but may have many exits. In contrast to an extended basicblock, a trace can contain join nodes. Since a trace always onlyfollows one single path through the original program, however, joinnodes are not recognizable as such in a trace and have a singlepredecessor node like regular nodes.Atyped traceis a trace annotated with a type for every variable(including temporaries) on the trace. A typed trace also has an entrytype mapgiving the required types for variables used on the tracebefore they are defined. For example, a trace could have a type map(x: int, b: boolean), meaning that the trace may be enteredonly if the value of the variablexis of typeintand the value ofbis of typeboolean. The entry type map is much like the signatureof a function.In this paper, we only discuss typed loop traces, and we willrefer to them simply as “traces”. The key property of typed looptraces is that they can be compiled to efficient machine code usingthe same techniques used for typed languages.In TraceMonkey, traces are recorded in trace-flavored SSALIR(low-level intermediate representation). In trace-flavored SSA (orTSSA), phi nodes appear only at the entry point, which is reachedboth on entry and via loop edges. The important LIR primitivesare constant values, memory loads and stores (by address andoffset), integer operators, floating-point operators, function calls,and conditional exits. Type conversions, such as integer to double,are represented by function calls. This makes the LIR used byTraceMonkey independent of the concrete type system and typeconversion rules of the source language. The LIR operations aregeneric enough that the backend compiler is language independent.Figure 3 shows an example LIR trace.Bytecode interpreters typically represent values in a variouscomplex data structures (e.g., hash tables) in a boxed format (i.e.,with attached type tag bits). Since a trace is intended to representefficient code that eliminates all that complexity, our traces oper-ate on unboxed values in simple variables and arrays as much aspossible.A trace records all its intermediate values in a small activationrecord area. To make variable accesses fast on trace, the trace alsoimports local and global variables by unboxing them and copyingthem to its activation record. Thus, the trace can read and writethese variables with simple loads and stores from a native activationrecording, independently of the boxing mechanism used by theinterpreter. When the trace exits, the VM boxes the values fromthis native storage location and copies them back to the interpreterstructures.For every control-flow branch in the source program, therecorder generates conditional exit LIR instructions. These instruc-tions exit from the trace if required control flow is different fromwhat it was at trace recording, ensuring that the trace instructionsare run only if they are supposed to. We call these instructionsguardinstructions.Most of our traces represent loops and end with the specialloopLIR instruction. This is just an unconditional branch to the top ofthe trace. Such traces return only via guards.Now, we describe the key optimizations that are performed aspart of recording LIR. All of these optimizations reduce complexdynamic language constructs to simple typed constructs by spe-cializing for the current trace. Each optimization requires guard in-structions to verify their assumptions about the state and exit thetrace if necessary.Type specialization.All LIR primitives apply to operands of specific types. Thus,LIR traces are necessarily type-specialized, and a compiler caneasily produce a translation that requires no type dispatches. Atypical bytecode interpreter carries tag bits along with each value,and to perform any operation, must check the tag bits, dynamicallydispatch, mask out the tag bits to recover the untagged value,perform the operation, and then reapply tags. LIR omits everythingexcept the operation itself.A potential problem is that some operations can produce valuesof unpredictable types. For example, reading a property from anobject could yield a value of any type, not necessarily the typeobserved during recording. The recorder emits guard instructionsthat conditionally exit if the operation yields a value of a differenttype from that seen during recording. These guard instructionsguarantee that as long as execution is on trace, the types of valuesmatch those of the typed trace. When the VM observes a side exitalong such a type guard, a new typed trace is recorded originatingat the side exit location, capturing the new type of the operation inquestion.Representation specialization: objects.In JavaScript, namelookup semantics are complex and potentially expensive becausethey include features like object inheritance andeval. To evaluatean object property read expression likeo.x, the interpreter mustsearch the property map ofoand all of its prototypes and parents.Property maps can be implemented with different data structures(e.g., per-object hash tables or shared hash tables), so the searchprocess also must dispatch on the representation of each objectfound during search. TraceMonkey can simply observe the result ofthe search process and record the simplest possible LIR to accessthe property value. For example, the search might finds the value ofo.xin the prototype ofo, which uses a shared hash-table represen-tation that placesxin slot 2 of a property vector. Then the recordedcan generate LIR that readso.xwith just two or three loads: one toget the prototype, possibly one to get the property value vector, andone more to get slot 2 from the vector. This is a vast simplificationand speedup compared to the original interpreter code. Inheritancerelationships and object representations can change during execu-tion, so the simplified code requires guard instructions that ensurethe object representation is the same. In TraceMonkey, objects’ rep-resentations are assigned an integer key called theobject shape.Thus, the guard is a simple equality check on the object shape.Representation specialization: numbers.JavaScript has nointeger type, only a Number type that is the set of 64-bit IEEE-754 floating-pointer numbers (“doubles”). But many JavaScriptoperators, in particular array accesses and bitwise operators, reallyoperate on integers, so they first convert the number to an integer,and then convert any integer result back to a double.Clearly, aJavaScript VM that wants to be fast must find a way to operate onintegers directly and avoid these conversions.In TraceMonkey, we support two representations for numbers:integers and doubles. The interpreter uses integer representationsas much as it can, switching for results that can only be representedas doubles. When a trace is started, some values may be importedand represented as integers. Some operations on integers requireguards. For example, adding two integers can produce a value toolarge for the integer representation.Function inlining.LIR traces can cross function boundariesin either direction, achieving function inlining. Move instructionsneed to be recorded for function entry and exit to copy argumentsin and return values out. These move statements are then optimizedaway by the compiler using copy propagation. In order to be ableto return to the interpreter, the trace must also generate LIR torecord that a call frame has been entered and exited. The frameentry and exit LIR saves just enough information to allow theintepreter call stack to be restored later and is much simpler thanthe interpreter’s standard call code. If the function being enteredis not constant (which in JavaScript includes any call by functionname), the recorder must also emit LIR to guard that the functionis the same.Guards and side exits.Each optimization described aboverequires one or more guards to verify the assumptions made indoing the optimization. A guard is just a group of LIR instructionsthat performs a test and conditional exit. The exit branches to aside exit, a small off-trace piece of LIR that returns a pointer toa structure that describes the reason for the exit along with theinterpreter PC at the exit point and any other data needed to restorethe interpreter’s state structures.Aborts.Some constructs are difficult to record in LIR traces.For example,evalor calls to external functions can change theprogram state in unpredictable ways, making it difficult for thetracer to know the current type map in order to continue tracing.A tracing implementation can also have any number of other limi-tations, e.g.,a small-memory device may limit the length of traces.When any situation occurs that prevents the implementation fromcontinuing trace recording, the implementationabortstrace record-ing and returns to the trace monitor.3.2Trace TreesEspecially simple loops, namely those where control flow, valuetypes, value representations, and inlined functions are all invariant,can be represented by a single trace. But most loops have at leastsome variation, and so the program will take side exits from themain trace. When a side exit becomes hot, TraceMonkey starts anewbranch tracefrom that point and patches the side exit to jumpdirectly to that trace. In this way, a single trace expands on demandto a single-entry, multiple-exittrace tree.This section explains how trace trees are formed during execu-tion. The goal is to form trace trees during execution that cover allthe hot paths of the program.Starting a tree.Tree trees always start at loop headers, becausethey are a natural place to look for hot paths. In TraceMonkey, loopheaders are easy to detect–the bytecode compiler ensures that abytecode is a loop header iff it is the target of a backward branch.TraceMonkey starts a tree when a given loop header has been exe-cuted a certain number of times (2 in the current implementation).Starting a tree just means starting recording a trace for the currentpoint and type map and marking the trace as the root of a tree. Eachtree is associated with a loop header and type map, so there may beseveral trees for a given loop header.Closing the loop.Trace recording can end in several ways.Ideally, the trace reaches the loop header where it started withthe same type map as on entry. This is called atype-stableloopiteration. In this case, the end of the trace can jump right to thebeginning, as all the value representations are exactly as needed toenter the trace. The jump can even skip the usual code that wouldcopy out the state at the end of the trace and copy it back in to thetrace activation record to enter a trace.In certain cases the trace might reach the loop header with adifferent type map. This scenario is sometime observed for the firstiteration of a loop. Some variables inside the loop might initially beundefined, before they are set to a concrete type during the first loopiteration. When recording such an iteration, the recorder cannotlink the trace back to its own loop header since it istype-unstable.Instead, the iteration is terminated with a side exit that will alwaysfail and return to the interpreter. At the same time a new trace isrecorded with the new type map. Every time an additional type-unstable trace is added to a region, its exit type map is compared tothe entry map of all existing traces in case they complement eachother. With this approach we are able to cover type-unstable loopiterations as long they eventually form a stable equilibrium.Finally, the trace might exit the loop before reaching the loopheader, for example because execution reaches abreakorreturnstatement. In this case, the VM simply ends the trace with an exitto the trace monitor.As mentioned previously, we may speculatively chose to rep-resent certain Number-typed values as integers on trace. We do sowhen we observe that Number-typed variables contain an integervalue at trace entry. If during trace recording the variable is unex-pectedly assigned a non-integer value, we have to widen the typeof the variable to a double. As a result, the recorded trace becomesinherently type-unstable since it starts with an integer value butends with a double value. This represents a mis-speculation, sinceat trace entry we specialized the Number-typed value to an integer,assuming that at the loop edge we would again find an integer valuein the variable, allowing us to close the loop. To avoid future spec-ulative failures involving this variable, and to obtain a type-stabletrace we note the fact that the variable in question as been observedto sometimes hold non-integer values in an advisory data structurewhich we call the “oracle”.When compiling loops, we consult the oracle before specializ-ing values to integers. Speculation towards integers is performedonly if no adverse information is known to the oracle about thatparticular variable. Whenever we accidentally compile a loop thatis type-unstable due to mis-speculation of a Number-typed vari-able, we immediately trigger the recording of a new trace, whichbased on the now updated oracle information will start with a dou-ble value and thus become type stable.Extending a tree.Side exits lead to different paths throughthe loop, or paths with different types or representations. Thus, tocompletely cover the loop, the VM must record traces starting at allside exits. These traces are recorded much like root traces: there isa counter for each side exit, and when the counter reaches a hotnessthreshold, recording starts. Recording stops exactly as for the roottrace, using the loop header of the root trace as the target to reach.Our implementation does not extend at all side exits. It extendsonly if the side exit is for a control-flow branch, and only if the sideexit does not leave the loop. In particular we do not want to extenda trace tree along a path that leads to an outer loop, because wewant to cover such paths in an outer tree through treenesting.3.3BlacklistingSometimes, a program follows a path that cannot be compiledinto a trace, usually because of limitations in the implementation.TraceMonkey does not currently support recording throwing andcatching of arbitrary exceptions. This design trade off was chosen,because exceptions are usually rare in JavaScript. However, if aprogram opts to use exceptions intensively, we would suddenlyincur a punishing runtime overhead if we repeatedly try to recorda trace for this path and repeatedly fail to do so, since we aborttracing every time we observe an exception being thrown.As a result, if a hot loop contains traces that always fail, the VMcould potentially run much more slowly than the base interpreter:the VM repeatedly spends time trying to record traces, but is neverable to run any. To avoid this problem, whenever the VM is aboutto start tracing, it must try to predict whether it will finish the trace.Our prediction algorithm is based onblacklistingtraces thathave been tried and failed. When the VM fails to finish a trace start-ing at a given point, the VM records that a failure has occurred. TheVM also sets a counter so that it will not try to record a trace startingat that point until it is passed a few more times (32 in our imple-mentation). Thisbackoffcounter gives temporary conditions thatprevent tracing a chance to end. For example, a loop may behavedifferently during startup than during its steady-state execution. Af-ter a given number of failures (2 in our implementation), the VMmarks the fragment as blacklisted, which means the VM will neveragain start recording at that point.After implementing this basic strategy, we observed that forsmall loops that get blacklisted, the system can spend a noticeableamount of time just finding the loop fragment and determining thatit has been blacklisted. We now avoid that problem by patching thebytecode. We define an extra no-op bytecode that indicates a loopheader. The VM calls into the trace monitor every time the inter-preter executes a loop header no-op. To blacklist a fragment, wesimply replace the loop header no-op with a regular no-op. Thus,the interpreter will never again even call into the trace monitor.There is a related problem we have not yet solved, which occurswhen a loop meets all of these conditions:The VM can form at least one root trace for the loop.There is at least one hot side exit for which the VM cannotcomplete a trace.The loop body is short.In this case, the VM will repeatedly pass the loop header, searchfor a trace, find it, execute it, and fall back to the interpreter.With a short loop body, the overhead of finding and calling thetrace is high, and causes performance to be even slower than thebasic interpreter. So far, in this situation we have improved theimplementation so that the VM can complete the branch trace.But it is hard to guarantee that this situation will never happen.As future work, this situation could be avoided by detecting andblacklisting loops for which the average trace call executes fewbytecodes before returning to the interpreter."},{"title":"Nested Trace Tree Formation","text":"Figure 7 shows basic trace tree compilation (11) applied to a nestedloop where the inner loop contains two paths. Usually, the innerloop (with header ati) becomes hot first, and a trace tree is rootedat that point. For example, the first recorded trace may be a cycleFigure 5.A tree with two traces, a trunk trace and one branchtrace. The trunk trace contains a guard to which a branch trace wasattached. The branch trace contain a guard that may fail and triggera side exit. Both the trunk and the branch trace loop back to the treeanchor, which is the beginning of the trace tree.Figure 6.We handle type-unstable loops by allowing traces tocompile that cannot loop back to themselves due to a type mis-match. As such traces accumulate, we attempt to connect their loopedges to form groups of trace trees that can execute without havingto side-exit to the interpreter to cover odd type cases. This is par-ticularly important for nested trace trees where an outer tree tries tocall an inner tree (or in this case a forest of inner trees), since innerloops frequently have initially undefined values which change typeto a concrete value after the first iteration.through the inner loop,{i, i, i, α}. Theαsymbol is used toindicate that the trace loops back the tree anchor.When execution leaves the inner loop, the basic design has twochoices. First, the system can stop tracing and give up on compilingthe outer loop, clearly an undesirable solution. The other choice isto continue tracing, compiling traces for the outer loop inside theinner loop’s trace tree.For example, the program might exit atiand record a branchtrace that incorporates the outer loop:{i, i, i, i, i, i, α}.Later, the program might take the other branch atiand thenexit, recording another branch trace incorporating the outer loop:{i, i, i, i, i, i, i, i, α}. Thus, the outer loop is recorded andcompiled twice, and both copies must be retained in the trace cache.Figure 7.Control flow graph of a nested loop with an if statementinside the inner most loop (a). An inner tree captures the innerloop, and is nested inside an outer tree which “calls” the inner tree.The inner tree returns to the outer tree once it exits along its loopcondition guard (b).In general, if loops are nested to depthk, and each loop hasnpaths(on geometric average), this na ̈ıve strategy yieldsO(n)traces,which can easily fill the trace cache.In order to execute programs with nested loops efficiently, atracing system needs a technique for covering the nested loops withnative code without exponential trace duplication.4.1Nesting AlgorithmThe key insight is that if each loop is represented by its own tracetree, the code for each loop can be contained only in its own tree,and outer loop paths will not be duplicated. Another key fact is thatwe are not tracing arbitrary bytecodes that might have irreduceablecontrol flow graphs, but rather bytecodes produced by a compilerfor a language with structured control flow. Thus, given two loopedges, the system can easily determine whether they are nestedand which is the inner loop. Using this knowledge, the system cancompile inner and outer loops separately, and make the outer loop’stracescallthe inner loop’s trace tree.The algorithm for building nested trace trees is as follows. Westart tracing at loop headers exactly as in the basic tracing system.When we exit a loop (detected by comparing the interpreter PCwith the range given by the loop edge), we stop the trace. Thekey step of the algorithm occurs when we are recording a tracefor loopL(Rfor loop being recorded) and we reach the headerof a different loopL(Ofor other loop). Note thatLmust be aninner loop ofLbecause we stop the trace when we exit a loop.IfLhas a type-matching compiled trace tree, we callLasa nested trace tree. If the call succeeds, then we record the callin the trace forL. On future executions, the trace forLwillcall the inner trace directly.IfLdoes not have a type-matching compiled trace tree yet,we have to obtain it before we are able to proceed. In orderto do this, we simply abort recording the first trace. The tracemonitor will see the inner loop header, and will immediatelystart recording the inner loop.If all the loops in a nest are type-stable, then loop nesting createsno duplication. Otherwise, if loops are nested to a depthk, and eachFigure 8.Control flow graph of a loop with two nested loops (left)and its nested trace tree configuration (right). The outer tree callsthe two inner nested trace trees and places guards at their side exitlocations.loop is entered withmdifferent type maps (on geometric average),then we compileO(m)copies of the innermost loop. As long asmis close to 1, the resulting trace trees will be tractable.An important detail is that the call to the inner trace tree must actlike a function call site: it must return to the same point every time.The goal of nesting is to make inner and outer loops independent;thus when the inner tree is called, it must exit to the same pointin the outer tree every time with the same type map. Because wecannot actually guarantee this property, we must guard on it afterthe call, and side exit if the property does not hold. A commonreason for the inner tree not to return to the same point wouldbe if the inner tree took a new side exit for which it had nevercompiled a trace. At this point, the interpreter PC is in the innertree, so we cannot continue recording or executing the outer tree.If this happens during recording, we abort the outer trace, to givethe inner tree a chance to finish growing. A future execution of theouter tree would then be able to properly finish and record a call tothe inner tree. If an inner tree side exit happens during execution ofa compiled trace for the outer tree, we simply exit the outer traceand start recording a new branch in the inner tree.4.2Blacklisting with NestingThe blacklisting algorithm needs modification to work well withnesting. The problem is that outer loop traces often abort duringstartup (because the inner tree is not available or takes a side exit),which would lead to their being quickly blacklisted by the basicalgorithm.The key observation is that when an outer trace aborts becausethe inner tree is not ready, this is probably a temporary condition.Thus, we should not count such aborts toward blacklisting as longas we are able to build up more traces for the inner tree.In our implementation, when an outer tree aborts on the innertree, we increment the outer tree’s blacklist counter as usual andback off on compiling it. When the inner tree finishes a trace, wedecrement the blacklist counter on the outer loop, “forgiving” theouter loop for aborting previously. We also undo the backoff so thatthe outer tree can start immediately trying to compile the next timewe reach it."},{"title":"Trace Tree Optimization","text":"This section explains how a recorded trace is translated to anoptimized machine code trace. The trace compilation subsystem,, is separate from the VM and can be used for otherapplications.5.1OptimizationsBecause traces are in SSA form and have no join points orφ-nodes, certain optimizations are easy to implement. In order toget good startup performance, the optimizations must run quickly,so we chose a small set of optimizations. We implemented theoptimizations as pipelined filters so that they can be turned on andoff independently, and yet all run in just two loop passes over thetrace: one forward and one backward.Every time the trace recorder emits a LIR instruction, the in-struction is immediately passed to the first filter in the forwardpipeline. Thus, forward filter optimizations are performed as thetrace is recorded. Each filter may pass each instruction to the nextfilter unchanged, write a different instruction to the next filter, orwrite no instruction at all. For example, the constant folding filtercan replace a multiply instruction likev:=mul3,1000with aconstant instructionv= 3000.We currently apply four forward filters:On ISAs without floating-point instructions, a soft-float filterconverts floating-point LIR instructions to sequences of integerinstructions.CSE (constant subexpression elimination),expression simplification, including constant folding and a fewalgebraic identities (e.g.,a−a= 0), andsource language semantic-specific expression simplification,primarily algebraic identities that allowto be replacedwith. For example, LIR that converts anto aand then back again would be removed by this filter.When trace recording is completed, nanojit runs the backwardoptimization filters. These are used for optimizations that requirebackward program analysis. When running the backward filters,nanojit reads one LIR instruction at a time, and the reads are passedthrough the pipeline.We currently apply three backward filters:Dead data-stack store elimination. The LIR trace encodes manystores to locations in the interpreter stack. But these values arenever read back before exiting the trace (by the interpreter oranother trace). Thus, stores to the stack that are overwrittenbefore the next exit are dead. Stores to locations that are offthe top of the interpreter stack at future exits are also dead.Dead call-stack store elimination. This is the same optimizationas above, except applied to the interpreter’s call stack used forfunction call inlining.Dead code elimination. This eliminates any operation thatstores to a value that is never used.After a LIR instruction is successfully read (“pulled”) fromthe backward filter pipeline, nanojit’s code generator emits nativemachine instruction(s) for it.5.2Register AllocationWe use a simple greedy register allocator that makes a singlebackward pass over the trace (it is integrated with the code gen-erator). By the time the allocator has reached an instruction likev=add v, v, it has already assigned a register tov. Ifvandvhave not yet been assigned registers, the allocator assigns a freeregister to each. If there are no free registers, a value is selected forspilling. We use a class heuristic that selects the “oldest” register-carried value (6).The heuristic considers the setRof valuesvin registers imme-diately after the current instruction for spilling. Letvbe the lastinstruction before the current where eachvis referred to. Then theTagJS TypeDescriptionxx1number31-bit integer representation000objectpointer to JSObject handle010numberpointer to double handle100stringpointer to JSString handle110booleanenumeration for null, undefined, true, falsenull, orundefinedFigure 9. Tagged values in the SpiderMonkey JS interpreter.Testing tags, unboxing (extracting the untagged value) and boxing(creating tagged values) are significant costs. Avoiding these costsis a key benefit of tracing.heuristic selectsvwith minimumv. The motivation is that thisfrees up a register for as long as possible given a single spill.If we need to spill a valuevat this point, we generate therestore code just after the code for the current instruction. Thecorresponding spill code is generated just after the last point wherevwas used. The register that was assigned tovis marked free forthe preceding code, because that register can now be used freelywithout affecting the following code"},{"title":"Implementation","text":"To demonstrate the effectiveness of our approach, we have im-plemented a trace-based dynamic compiler for the SpiderMonkeyJavaScript Virtual Machine (4). SpiderMonkey is the JavaScriptVM embedded in Mozilla’s Firefox open-source web browser (2),which is used by more than 200 million users world-wide. The coreof SpiderMonkey is a bytecode interpreter implemented in C++.In SpiderMonkey, all JavaScript values are represented by thetypejsval. Ajsvalis machine word in which up to the 3 of theleast significant bits are a type tag, and the remaining bits are data.See Figure 6 for details. All pointers contained injsvalspoint toGC-controlled blocks aligned on 8-byte boundaries.JavaScriptobjectvalues are mappings of string-valued propertynames to arbitrary values. They are represented in one of two waysin SpiderMonkey. Most objects are represented by a shared struc-tural description, called theobject shape, that maps property namesto array indexes using a hash table. The object stores a pointer tothe shape and the array of its own property values. Objects withlarge, unique sets of property names store their properties directlyin a hash table.The garbage collector is an exact, non-generational, stop-the-world mark-and-sweep collector.In the rest of this section we discuss key areas of the TraceMon-key implementation.6.1Calling Compiled TracesCompiled traces are stored in atrace cache, indexed by intepreterPC and type map. Traces are compiled so that they may becalled as functions using standard native calling conventions (e.g.,FASTCALLon x86).The interpreter must hit a loop edge and enter the monitor inorder to call a native trace for the first time. The monitor computesthe current type map, checks the trace cache for a trace for thecurrent PC and type map, and if it finds one, executes the trace.To execute a trace, the monitor must build a trace activationrecord containing imported local and global variables, temporarystack space, and space for arguments to native calls. The local andglobal values are then copied from the interpreter state to the traceactivation record. Then, the trace is called like a normal C functionpointer.When a trace call returns, the monitor restores the interpreterstate. First, the monitor checks the reason for the trace exit andapplies blacklisting if needed. Then, it pops or synthesizes inter-preter JavaScript call stack frames as needed. Finally, it copies theimported variables back from the trace activation record to the in-terpreter state.At least in the current implementation, these steps have a non-negligible runtime cost, so minimizing the number of interpreter-to-trace and trace-to-interpreter transitions is essential for perfor-mance. (see also Section 3.3). Our experiments (see Figure 12)show that for programs we can trace well such transitions hap-pen infrequently and hence do not contribute significantly to totalruntime. In a few programs, where the system is prevented fromrecording branch traces for hot side exits by aborts, this cost canrise to up to 10% of total execution time.6.2Trace StitchingTransitions from a trace to a branch trace at a side exit avoid thecosts of calling traces from the monitor, in a feature calledtracestitching. At a side exit, the exiting trace only needs to write liveregister-carried values back to its trace activation record. In our im-plementation, identical type maps yield identical activation recordlayouts, so the trace activation record can be reused immediatelyby the branch trace.In programs with branchy trace trees with small traces, tracestitching has a noticeable cost. Although writing to memory andthen soon reading back would be expected to have a high L1cache hit rate, for small traces the increased instruction count hasa noticeable cost. Also, if the writes and reads are very closein the dynamic instruction stream, we have found that currentx86 processors often incur penalties of 6 cycles or more (e.g., ifthe instructions use different base registers with equal values, theprocessor may not be able to detect that the addresses are the sameright away).The alternate solution is to recompile an entire trace tree, thusachieving inter-trace register allocation (10). The disadvantage isthat tree recompilation takes time quadratic in the number of traces.We believe that the cost of recompiling a trace tree every timea branch is added would be prohibitive. That problem might bemitigated by recompiling only at certain points, or only for veryhot, stable trees.In the future, multicore hardware is expected to be common,making background tree recompilation attractive. In a closely re-lated project (13) background recompilation yielded speedups ofup to 1.25x on benchmarks with many branch traces. We plan toapply this technique to TraceMonkey as future work.6.3Trace RecordingThe job of the trace recorder is to emit LIR with identical semanticsto the currently running interpreter bytecode trace. A good imple-mentation should have low impact on non-tracing interpreter per-formance and a convenient way for implementers to maintain se-mantic equivalence.In our implementation, the only direct modification to the inter-preter is a call to the trace monitor at loop edges. In our benchmarkresults (see Figure 12) the total time spent in the monitor (for allactivities) is usually less than 5%, so we consider the interpreterimpact requirement met. Incrementing the loop hit counter is ex-pensive because it requires us to look up the loop in the trace cache,but we have tuned our loops to become hot and trace very quickly(on the second iteration). The hit counter implementation could beimproved, which might give us a small increase in overall perfor-mance, as well as more flexibility with tuning hotness thresholds.Once a loop is blacklisted we never call into the trace monitor forthat loop (see Section 3.3).Recording is activated by a pointer swap that sets the inter-preter’s dispatch table to call a single “interrupt” routine for ev-ery bytecode. The interrupt routine first calls a bytecode-specificrecording routine. Then, it turns off recording if necessary (e.g.,the trace ended). Finally, it jumps to the standard interpreter byte-code implementation. Some bytecodes have effects on the type mapthat cannot be predicted before executing the bytecode (e.g., call-ingString.charCodeAt, which returns an integer orNaNif theindex argument is out of range). For these, we arrange for the inter-preter to call into the recorder again after executing the bytecode.Since such hooks are relatively rare, we embed them directly intothe interpreter, with an additional runtime check to see whether arecorder is currently active.While separating the interpreter from the recorder reduces indi-vidual code complexity, it also requires careful implementation andextensive testing to achieve semantic equivalence.In some cases achieving this equivalence is difficult since Spi-derMonkey follows afat-bytecodedesign, which was found to bebeneficial to pure interpreter performance.In fat-bytecode designs, individual bytecodes can implementcomplex processing (e.g., thegetpropbytecode, which imple-ments full JavaScript property value access, including special casesfor cached and dense array access).Fat bytecodes have two advantages: fewer bytecodes meanslower dispatch cost, and bigger bytecode implementations give thecompiler more opportunities to optimize the interpreter.Fat bytecodes are a problem for TraceMonkey because theyrequire the recorder to reimplement the same special case logicin the same way. Also, the advantages are reduced because (a)dispatch costs are eliminated entirely in compiled traces, (b) thetraces contain only one special case, not the interpreter’s largechunk of code, and (c) TraceMonkey spends less time running thebase interpreter.One way we have mitigated these problems is by implementingcertain complex bytecodes in the recorder as sequences of simplebytecodes. Expressing the original semantics this way is not too dif-ficult, and recording simple bytecodes is much easier. This enablesus to retain the advantages of fat bytecodes while avoiding some oftheir problems for trace recording. This is particularly effective forfat bytecodes that recurse back into the interpreter, for example toconvert an object into a primitive value by invoking a well-knownmethod on the object, since it lets us inline this function call.It is important to note that we split fat opcodes into thinner op-codes only during recording. When running purely interpretatively(i.e. code that has been blacklisted), the interpreter directly and ef-ficiently executes the fat opcodes.6.4PreemptionSpiderMonkey, like many VMs, needs to preempt the user programperiodically. The main reasons are to prevent infinitely loopingscripts from locking up the host system and to schedule GC.In the interpreter, this had been implemented by setting a “pre-empt now” flag that was checked on every backward jump. Thisstrategy carried over into TraceMonkey: the VM inserts a guard onthe preemption flag at every loop edge. We measured less than a1% increase in runtime on most benchmarks for this extra guard.In practice, the cost is detectable only for programs with very shortloops.We tested and rejected a solution that avoided the guards bycompiling the loop edge as an unconditional jump, and patchingthe jump target to an exit routine when preemption is required.This solution can make the normal case slightly faster, but thenpreemption becomes very slow. The implementation was also verycomplex, especially trying to restart execution after the preemption.6.5Calling External FunctionsLike most interpreters, SpiderMonkey has a foreign function inter-face (FFI) that allows it to call C builtins and host system functions(e.g., web browser control and DOM access). The FFI has a stan-dard signature for JS-callable functions, the key argument of whichis an array of boxed values. External functions called through theFFI interact with the program state through an interpreter API (e.g.,to read a property from an argument). There are also certain inter-preter builtins that do not use the FFI, but interact with the programstate in the same way, such as theCallIteratorNextfunctionused with iterator objects. TraceMonkey must support this FFI inorder to speed up code that interacts with the host system inside hotloops.Calling external functions from TraceMonkey is potentially dif-ficult because traces do not update the interpreter state until exit-ing. In particular, external functions may need the call stack or theglobal variables, but they may be out of date.For the out-of-date call stack problem, we refactored some ofthe interpreter API implementation functions to re-materialize theinterpreter call stack on demand.We developed a C++ static analysis and annotated some inter-preter functions in order to verify that the call stack is refreshedat any point it needs to be used. In order to access the call stack,a function must be annotated as either FSor R-S. These annotations are also required in order to callRSfunctions, which are presumed to access the callstack transitively. FSis a trusted annotation, appliedto only 5 functions, that means the function refreshes the call stack.RSis an untrusted annotation that means the func-tion may only be called if the call stack has already been refreshed.Similarly, we detect when host functions attempt to directlyread or write global variables, and force the currently running traceto side exit. This is necessary since we cache and unbox globalvariables into the activation record during trace execution.Since both call-stack access and global variable access arerarely performed by host functions, performance is not significantlyaffected by these safety mechanisms.Another problem is that external functions can reenter the inter-preter by calling scripts, which in turn again might want to accessthe call stack or global variables. To address this problem, we madethe VM set a flag whenever the interpreter is reentered while a com-piled trace is running.Every call to an external function then checks this flag and exitsthe trace immediately after returning from the external function callif it is set. There are many external functions that seldom or neverreenter, and they can be called without problem, and will causetrace exit only if necessary.The FFI’s boxed value array requirement has a performancecost, so we defined a new FFI that allows C functions to be an-notated with their argument types so that the tracer can call themdirectly, without unnecessary argument conversions.Currently, we do not support calling native property get and setoverride functions or DOM functions directly from trace. Supportis planned future work.6.6CorrectnessDuring development, we had access to existing JavaScript testsuites, but most of them were not designed with tracing VMs inmind and contained few loops.One tool that helped us greatly was Mozilla’s JavaScript fuzztester,, which generates random JavaScript programsby nesting random language elements. We modifiedto generate loops, and also to test more heavily certain constructswe suspected would reveal flaws in our implementation. For exam-ple, we suspected bugs in TraceMonkey’s handling of type-unstableFigure 11. Fraction of dynamic bytecodes executed by inter-preter and on native traces.The speedup vs. interpreter is shownin parentheses next to each test. The fraction of bytecodes exe-cuted while recording is too small to see in this figure, exceptforcrypto-md5, where fully 3% of bytecodes are executed whilerecording. In most of the tests, almost all the bytecodes are exe-cuted by compiled traces. Three of the benchmarks are not tracedat all and run in the interpreter.loops and heavily branching code, and a specialized fuzz tester in-deed revealed several regressions which we subsequently corrected."},{"title":"Evaluation","text":"We evaluated our JavaScript tracing implementation using Sun-Spider, the industry standard JavaScript benchmark suite. SunSpi-der consists of 26 short-running (less than 250ms, average 26ms)JavaScript programs. This is in stark contrast to benchmark suitessuch as SpecJVM98 (3) used to evaluate desktop and server JavaVMs. Many programs in those benchmarks use large data sets andexecute for minutes. The SunSpider programs carry out a variety oftasks, primarily 3d rendering, bit-bashing, cryptographic encoding,math kernels, and string processing.All experiments were performed on a MacBook Pro with 2.2GHz Core 2 processor and 2 GB RAM running MacOS 10.5.Benchmark results.The main question is whether programsrun faster with tracing. For this, we ran the standard SunSpider testdriver, which starts a JavaScript interpreter, loads and runs eachprogram once for warmup, then loads and runs each program 10times and reports the average time taken by each. We ran 4 differ-ent configurations for comparison: (a) SpiderMonkey, the baselineinterpreter, (b) TraceMonkey, (d) SquirrelFish Extreme (SFX), thecall-threaded JavaScript interpreter used in Apple’s WebKit, and(e) V8, the method-compiling JavaScript VM from Google.Figure 10 shows the relative speedups achieved by tracing, SFX,and V8 against the baseline (SpiderMonkey). Tracing achieves thebest speedups in integer-heavy benchmarks, up to the 25x speeduponbitops-bitwise-and.TraceMonkey is the fastest VM on 9 of the 26 benchmarks(3d-morph,bitops-3bit-bits-in-byte,bitops-bitwise-and,crypto-sha1,math-cordic,math-partial-sums,math-spectral-norm,string-base64,string-validate-input).Figure 10.Speedup vs. a baseline JavaScript interpreter (SpiderMonkey) for our trace-based JIT compiler, Apple’s SquirrelFish Extremeinline threading interpreter and Google’s V8 JS compiler. Our system generates particularly efficient code for programs that benefit most fromtype specialization, which includes SunSpider Benchmark programs that perform bit manipulation. We type-specialize the code in questionto use integer arithmetic, which substantially improves performance. For one of the benchmark programs we execute 25 times faster thanthe SpiderMonkey interpreter, and almost 5 times faster than V8 and SFX. For a large number of benchmarks all three VMs produce similarresults. We perform worst on benchmark programs that we do not trace and instead fall back onto the interpreter. This includes the recursivebenchmarksaccess-binary-treesandcontrol-flow-recursive, for which we currently don’t generate any native code.In particular, thebitopsbenchmarks are short programs that per-form many bitwise operations, so TraceMonkey can cover the en-tire program with 1 or 2 traces that operate on integers. TraceMon-key runs all the other programs in this set almost entirely as nativecode.regexp-dnais dominated by regular expression matching,which is implemented in all 3 VMs by a special regular expressioncompiler. Thus, performance on this benchmark has little relationto the trace compilation approach discussed in this paper.TraceMonkey’s smaller speedups on the other benchmarks canbe attributed to a few specific causes:The implementation does not currently trace recursion, soTraceMonkey achieves a small speedup or no speedup onbenchmarks that use recursion extensively:3d-cube,3d-raytrace,access-binary-trees,string-tagcloud, andcontrolflow-recursive.The implementation does not currently traceevaland someother functions implemented in C. Becausedate-format-tofteanddate-format-xparbuse such functions in theirmain loops, we do not trace them.The implementation does not currently trace through regularexpressionreplaceoperations. The replace function can bepassed a function object used to compute the replacement text.Our implementation currently does not trace functions calledas replace functions. The run time ofstring-unpack-codeisdominated by such areplacecall.Two programs trace well, but have a long compilation time.access-nbodyforms a large number of traces (81).crypto-md5forms one very long trace. We expect to improve performanceon this programs by improving the compilation speed of nano-jit.Some programs trace very well, and speed up compared tothe interpreter, but are not as fast as SFX and/or V8, namelybitops-bits-in-byte,bitops-nsieve-bits,access-fannkuch,access-nsieve, andcrypto-aes. The reason isnot clear, but all of these programs have nested loops withsmall bodies, so we suspect that the implementation has a rela-tively high cost for calling nested traces.string-fastatraceswell, but its run time is dominated by string processing builtins,which are unaffected by tracing and seem to be less efficient inSpiderMonkey than in the two other VMs.Detailed performance metrics.In Figure 11 we show the frac-tion of instructions interpreted and the fraction of instructions exe-cuted as native code. This figure shows that for many programs, weare able to execute almost all the code natively.Figure 12 breaks down the total execution time into four activ-ities: interpreting bytecodes while not recording, recording traces(including time taken to interpret the recorded trace), compilingtraces to native code, and executing native code traces.These detailed metrics allow us to estimate parameters for asimple model of tracing performance. These estimates should beconsidered very rough, as the values observed on the individualbenchmarks have large standard deviations (on the order of theLoopsTreesTracesAbortsFlushesTrees/LoopTraces/TreeTraces/LoopSpeedup3d-cube252729301.11.11.22.20x3d-morph588201.61.01.62.86x3d-raytrace10251001012.54.010.01.18xaccess-binary-trees00050---0.93xaccess-fannkuch1034572403.41.75.72.20xaccess-nbody81618502.01.12.34.19xaccess-nsieve368302.01.32.73.05xbitops-3bit-bits-in-byte222001.01.01.025.47xbitops-bits-in-byte334101.01.31.38.67xbitops-bitwise-and111001.01.01.025.20xbitops-nsieve-bits335001.01.71.72.75xcontrolflow-recursive00010---0.98xcrypto-aes5072781901.41.11.61.64xcrypto-md5445001.01.31.32.30xcrypto-sha15510001.02.02.05.95xdate-format-tofte334701.01.31.31.07xdate-format-xparb3311301.03.73.70.98xmath-cordic245102.01.32.54.92xmath-partial-sums244102.01.02.05.90xmath-spectral-norm152020001.31.01.37.12xregexp-dna222001.01.01.04.21xstring-base64357001.71.42.32.53xstring-fasta51115602.21.43.01.49xstring-tagcloud366502.01.02.01.09xstring-unpack-code4437001.09.39.31.20xstring-validate-input61013101.71.32.21.86xFigure 13.Detailed trace recording statistics for the SunSpider benchmark set.mean). We excluderegexp-dnafrom the following calculations,because most of its time is spent in the regular expression matcher,which has much different performance characteristics from theother programs. (Note that this only makes a difference of about10% in the results.) Dividing the total execution time in processorclock cycles by the number of bytecodes executed in the baseinterpreter shows that on average, a bytecode executes in about35 cycles. Native traces take about 9 cycles per bytecode, a 3.9xspeedup over the interpreter.Using similar computations, we find that trace recording takesabout 3800 cycles per bytecode, and compilation 3150 cycles perbytecode. Hence, during recording and compiling the VM runs at1/200 the speed of the interpreter. Because it costs 6950 cycles tocompile a bytecode, and we save 26 cycles each time that code isrun natively, we break even after running a trace 270 times.The other VMs we compared with achieve an overall speedupof 3.0x relative to our baseline interpreter. Our estimated nativecode speedup of 3.9x is significantly better. This suggests thatour compilation techniques can generate more efficient native codethan any other current JavaScript VM.These estimates also indicate that our startup performance couldbe substantially better if we improved the speed of trace recordingand compilation. The estimated 200x slowdown for recording andcompilation is very rough, and may be influenced by startup factorsin the interpreter (e.g., caches that have not warmed up yet duringrecording). One observation supporting this conjecture is that inthe tracer, interpreted bytecodes take about 180 cycles to run. Still,recording and compilation are clearly both expensive, and a betterimplementation, possibly including redesign of the LIR abstractsyntax or encoding, would improve startup performance.Our performance results confirm that type specialization usingtrace trees substantially improves performance. We are able tooutperform the fastest available JavaScript compiler (V8) and thefastest available JavaScript inline threaded interpreter (SFX) on 9of 26 benchmarks."},{"title":"Related Work","text":"Trace optimization for dynamic languages.The closest area ofrelated work is on applying trace optimization to type-specializedynamic languages. Existing work shares the idea of generatingtype-specialized code speculatively with guards along interpretertraces.To our knowledge, Rigo’s Psyco (16) is the only publishedtype-specializing trace compiler for a dynamic language (Python).Psyco does not attempt to identify hot loops or inline function calls.Instead, Psyco transforms loops to mutual recursion before runningand traces all operations.Pall’s LuaJIT is a Lua VM in development that uses trace com-pilation ideas. (1). There are no publications on LuaJIT but the cre-ator has told us that LuaJIT has a similar design to our system, butwill use a less aggressive type speculation (e.g., using a floating-point representation for all number values) and does not generatenested traces for nested loops.General trace optimization.General trace optimization hasa longer history that has treated mostly native code and typedlanguages like Java. Thus, these systems have focused less on typespecialization and more on other optimizations.Dynamo (7) by Bala et al, introduced native code tracing as areplacement for profile-guided optimization (PGO). A major goalwas to perform PGO online so that the profile was specific tothe current execution. Dynamo used loop headers as candidate hottraces, but did not try to create loop traces specifically.Trace trees were originally proposed by Gal et al. (11) in thecontext of Java, a statically typed language. Their trace trees ac-tually inlined parts of outer loops within the inner loops (becauseFigure 12. Fraction of time spent on major VM activities.Thespeedup vs. interpreter is shown in parentheses next to each test.Most programs where the VM spends the majority of its time run-ning native code have a good speedup. Recording and compilationcosts can be substantial; speeding up those parts of the implemen-tation would improve SunSpider performance.inner loops become hot first), leading to much greater tail duplica-tion.YETI, from Zaleski et al. (19) applied Dynamo-style tracingto Java in order to achieve inlining, indirect jump elimination,and other optimizations. Their primary focus was on designing aninterpreter that could easily be gradually re-engineered as a tracingVM.Suganuma et al. (18) described region-based compilation (RBC),a relative of tracing. A region is an subprogram worth optimizingthat can include subsets of any number of methods. Thus, the com-piler has more flexibility and can potentially generate better code,but the profiling and compilation systems are correspondingly morecomplex.Type specialization for dynamic languages.Dynamic lan-guage implementors have long recognized the importance of typespecialization for performance. Most previous work has focused onmethods instead of traces.Chambers et. al (9) pioneered the idea of compiling multipleversions of a procedure specialized for the input types in the lan-guage Self. In one implementation, they generated a specializedmethod online each time a method was called with new input types.In another, they used an offline whole-program static analysis toinfer input types and constant receiver types at call sites. Interest-ingly, the two techniques produced nearly the same performance.Salib (17) designed a type inference algorithm for Python basedon the Cartesian Product Algorithm and used the results to special-ize on types and translate the program to C++.McCloskey (14) has work in progress based on a language-independent type inference that is used to generate efficient Cimplementations of JavaScript and Python programs.Native code generation by interpreters.The traditional inter-preter design is a virtual machine that directly executes ASTs ormachine-code-like bytecodes. Researchers have shown how to gen-erate native code with nearly the same structure but better perfor-mance.Call threading, also known as context threading (8), compilesmethods by generating a native call instruction to an interpretermethod for each interpreter bytecode. A call-return pair has beenshown to be a potentially much more efficient dispatch mechanismthan the indirect jumps used in standard bytecode interpreters.Inline threading (15) copies chunks of interpreter native codewhich implement the required bytecodes into a native code cache,thus acting as a simple per-method JIT compiler that eliminates thedispatch overhead.Neither call threading nor inline threading perform type special-ization.Apple’s SquirrelFish Extreme (5) is a JavaScript implementa-tion based on call threading with selective inline threading. Com-bined with efficient interpreter engineering, these threading tech-niques have given SFX excellent performance on the standard Sun-Spider benchmarks.Google’s V8 is a JavaScript implementation primarily basedon inline threading, with call threading only for very complexoperations."},{"title":"Conclusions","text":"This paper described how to run dynamic languages efficiently byrecording hot traces and generating type-specialized native code.Our technique focuses on aggressively inlined loops, and for eachloop, it generates a tree of native code traces representing thepaths and value types through the loop observed at run time. Weexplained how to identify loop nesting relationships and generatenested traces in order to avoid excessive code duplication dueto the many paths through a loop nest. We described our typespecialization algorithm. We also described our trace compiler,which translates a trace from an intermediate representation tooptimized native code in two linear passes.Our experimental results show that in practice loops typicallyare entered with only a few different combinations of value typesof variables. Thus, a small number of traces per loop is sufficientto run a program efficiently. Our experiments also show that onprograms amenable to tracing, we achieve speedups of 2x to 20x."},{"title":"Future Work","text":"Work is underway in a number of areas to further improve theperformance of our trace-based JavaScript compiler. We currentlydo not trace across recursive function calls, but plan to add thesupport for this capability in the near term. We are also exploringadoption of the existing work on tree recompilation in the contextof the presented dynamic compiler in order to minimize JIT pausetimes and obtain the best of both worlds, fast tree stitching as wellas the improved code quality due to tree recompilation.We also plan on adding support for tracing across regular ex-pression substitutions using lambda functions, function applica-tions and expression evaluation usingeval. All these languageconstructs are currently executed via interpretation, which limitsour performance for applications that use those features."},{"title":"References","text":"[1] LuaJIT roadmap 2008 - http://lua-users.org/lists/lua-l/2008-02/msg00051.html.[2] Mozilla — Firefox web browser and Thunderbird email client -http://www.mozilla.com.[3] SPECJVM98 - http://www.spec.org/jvm98/.[4] SpiderMonkey (JavaScript-C) Engine -http://www.mozilla.org/js/spidermonkey/.[5] Surfin’ Safari - Blog Archive - Announcing SquirrelFish Extreme -http://webkit.org/blog/214/introducing-squirrelfish-extreme/.[6] A. Aho, R. Sethi, J. Ullman, and M. Lam. Compilers: Principles,techniques, and tools, 2006.[7] V. Bala, E. Duesterwald, and S. Banerjia. Dynamo: A transparentdynamic optimization system. In Proceedings of the ACM SIGPLANConference on Programming Language Design and Implementation,pages 1–12. ACM Press, 2000.[8] M. Berndl, B. Vitale, M. Zaleski, and A. Brown. Context Threading:a Flexible and Efficient Dispatch Technique for Virtual Machine In-terpreters. In Code Generation and Optimization, 2005. CGO 2005.International Symposium on, pages 15–26, 2005.[9] C. Chambers and D. Ungar. Customization: Optimizing CompilerTechnology for SELF, a Dynamically-Typed O bject-Oriented Pro-gramming Language. In Proceedings of the ACM SIGPLAN 1989Conference on Programming Language Design and Implementation,pages 146–160. ACM New York, NY, USA, 1989.[10] A. Gal. Efficient Bytecode Verification and Compilation in a VirtualMachine Dissertation. PhD thesis, University Of California, Irvine,2006.[11] A. Gal, C. W. Probst, and M. Franz. HotpathVM: An effective JITcompiler for resource-constrained devices. In Proceedings of theInternational Conference on Virtual Execution Environments, pages144–153. ACM Press, 2006.[12] C. Garrett, J. Dean, D. Grove, and C. Chambers. Measurement andApplication of Dynamic Receiver Class Distributions. 1994.[13] J. Ha, M. R. Haghighat, S. Cong, and K. S. McKinley. A concurrenttrace-based just-in-time compiler for javascript. Dept.of ComputerSciences, The University of Texas at Austin, TR-09-06, 2009.[14] B. McCloskey. Personal communication.[15] I. Piumarta and F. Riccardi. Optimizing direct threaded code by selec-tive inlining. In Proceedings of the ACM SIGPLAN 1998 conferenceon Programming language design and implementation, pages 291–300. ACM New York, NY, USA, 1998.[16] A. Rigo. Representation-Based Just-In-time Specialization and thePsyco Prototype for Python. In PEPM, 2004.[17] M. Salib. Starkiller: A Static Type Inferencer and Compiler forPython. In Master’s Thesis, 2004.[18] T. Suganuma, T. Yasue, and T. Nakatani. A Region-Based Compila-tion Technique for Dynamic Compilers. ACM Transactions on Pro-gramming Languages and Systems (TOPLAS), 28(1):134–174, 2006.[19] M. Zaleski, A. D. Brown, and K. Stoodley. YETI: A graduallYExtensible Trace Interpreter. In Proceedings of the InternationalConference on Virtual Execution Environments, pages 83–93. ACMPress, 2007."},{"title":"References","text":""}]